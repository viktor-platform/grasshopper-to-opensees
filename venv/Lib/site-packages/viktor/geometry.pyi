import abc
import numpy as np
import trimesh
import uuid
from .core import Color, File
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from typing import Any, Iterator, Sequence, TextIO, TypeVar

__all__ = ['Arc', 'ArcExtrusion', 'ArcRevolve', 'BidirectionalPattern', 'CartesianAxes', 'CircularExtrusion', 'Cone', 'Extrusion', 'GeoPoint', 'GeoPolygon', 'GeoPolyline', 'Group', 'Line', 'LineRevolve', 'LinearPattern', 'Material', 'Pattern', 'Point', 'Polygon', 'Polyline', 'RDWGSConverter', 'RectangularExtrusion', 'Revolve', 'Sphere', 'SquareBeam', 'Torus', 'TransformableObject', 'Triangle', 'TriangleAssembly', 'Vector']

T = TypeVar('T')

class Vector:
    x: Incomplete
    y: Incomplete
    z: Incomplete
    def __init__(self, x: float, y: float, z: float = 0) -> None: ...
    def __getitem__(self, index: int) -> float: ...
    def __iter__(self) -> Iterator[float]: ...
    def __eq__(self, other: object) -> bool: ...
    def __neg__(self) -> Vector: ...
    def __add__(self, other: Vector) -> Vector: ...
    def __sub__(self, other: Vector) -> Vector: ...
    def __mul__(self, other: float) -> Vector: ...
    def __rmul__(self, other: float) -> Vector: ...
    @property
    def squared_magnitude(self) -> float: ...
    @property
    def magnitude(self) -> float: ...
    @property
    def coordinates(self) -> tuple[float, float, float]: ...
    def normalize(self) -> Vector: ...
    def dot(self, other: Vector) -> float: ...
    def cross(self, other: Vector) -> Vector: ...

class _GLTF:
    @staticmethod
    def add_geometry_to_scene(scene: trimesh.Scene, geometry: trimesh.parent.Geometry3D, *, transform: np.ndarray = None, **metadata: Any) -> str: ...
    @classmethod
    def to_gltf(cls, *objects: TransformableObject) -> File: ...

class Material:
    uuid: Incomplete
    name: Incomplete
    density: Incomplete
    price: Incomplete
    color: Incomplete
    roughness: Incomplete
    metalness: Incomplete
    opacity: Incomplete
    def __init__(self, name: str = None, density: float = None, price: float = None, *, threejs_type: str = 'MeshStandardMaterial', roughness: float = 1.0, metalness: float = 0.5, opacity: float = 1.0, color: Color = ...) -> None: ...

class TransformableObject(ABC, metaclass=abc.ABCMeta):
    def __init__(self, *, identifier: str = None) -> None: ...
    def translate(self, translation_vector: Vector | tuple[float, float, float]) -> TransformableObject: ...
    def rotate(self, angle: float, direction: Vector | tuple[float, float, float], point: Point | tuple[float, float, float] = None) -> TransformableObject: ...
    def mirror(self, point: Point | tuple[float, float, float], normal: Vector | tuple[float, float, float]) -> TransformableObject: ...
    def scale(self, scaling_vector: Vector | tuple[float, float, float]) -> TransformableObject: ...

class Group(TransformableObject):
    def __init__(self, objects: Sequence[TransformableObject], *, identifier: str = None) -> None: ...
    def add(self, objects: list | tuple | TransformableObject) -> None: ...
    @property
    def children(self) -> list[TransformableObject]: ...
    def duplicate(self) -> Group: ...

class Point:
    def __init__(self, x: float, y: float, z: float = 0) -> None: ...
    def __getitem__(self, index: int) -> float: ...
    def __iter__(self) -> Iterator[float]: ...
    def __eq__(self, other: object) -> bool: ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    @property
    def z(self) -> float: ...
    @property
    def coordinates(self) -> np.ndarray: ...
    def copy(self) -> Point: ...
    def coincides_with(self, other: Point) -> bool: ...
    def vector_to(self, point: Point | tuple[float, float, float]) -> Vector: ...
    def get_local_coordinates(self, local_origin: Point | tuple[float, float, float], spherical: bool = False) -> np.ndarray: ...

class Line(TransformableObject):
    color: Incomplete
    def __init__(self, start_point: Point | tuple[float, float, float], end_point: Point | tuple[float, float, float], *, color: Color = ..., identifier: str = None) -> None: ...
    def __getitem__(self, index: int) -> Point: ...
    def __iter__(self) -> Iterator[Point]: ...
    def __eq__(self, other: object) -> bool: ...
    @property
    def start_point(self) -> Point: ...
    @property
    def end_point(self) -> Point: ...
    @property
    def length(self) -> float: ...
    def direction(self, normalize: bool = True) -> Vector: ...
    def collinear(self, point: Point | tuple[float, float, float]) -> bool: ...
    def project_point(self, point: Point | tuple[float, float, float]) -> Point: ...
    def distance_to_point(self, point: Point | tuple[float, float, float]) -> float: ...
    @property
    def length_vector(self) -> np.ndarray: ...
    @property
    def unit_vector(self) -> np.ndarray: ...
    @property
    def geometries(self) -> tuple[Point, Point]: ...
    @property
    def horizontal(self) -> bool: ...
    @property
    def vertical(self) -> bool: ...
    def discretize(self, num: int = 2) -> list[Point]: ...
    def revolve(self, *, material: Material = None, identifier: str = None, **kwargs: Any) -> LineRevolve: ...
    def get_line_function_parameters(self) -> tuple[float, float]: ...
    def find_overlap(self, other: Line, inclusive: bool = False) -> Point | Line | None: ...

class Revolve(TransformableObject, ABC, metaclass=abc.ABCMeta):
    material: Incomplete
    def __init__(self, *args: Any, rotation_angle: float = None, material: Material = None, identifier: str = None, **kwargs: Any) -> None: ...
    @property
    @abstractmethod
    def surface_area(self) -> float: ...
    @property
    @abstractmethod
    def inner_volume(self) -> float: ...
    @property
    def thickness(self) -> float: ...
    @thickness.setter
    def thickness(self, thickness: float) -> None: ...
    @property
    def mass(self) -> float: ...

class LineRevolve(Revolve):
    def __init__(self, line: Line, *args: Any, material: Material = None, identifier: str = None, **kwargs: Any) -> None: ...
    @property
    def line(self) -> Line: ...
    @property
    def uuid(self) -> uuid.UUID: ...
    @property
    def height(self) -> float: ...
    @property
    def surface_area(self) -> float: ...
    @property
    def inner_volume(self) -> float: ...
    @property
    def geometries(self) -> tuple[Line, ...]: ...

class Arc(TransformableObject):
    color: Incomplete
    def __init__(self, centre_point: Point | tuple[float, float, float], start_point: Point | tuple[float, float, float], end_point: Point | tuple[float, float, float], short_arc: bool = True, *, n_segments: int = 30, color: Color = ..., identifier: str = None) -> None: ...
    @property
    def radius(self) -> float: ...
    @property
    def centre_point(self) -> Point: ...
    @property
    def start_point(self) -> Point: ...
    @property
    def end_point(self) -> Point: ...
    @property
    def n_segments(self) -> int: ...
    @property
    def theta1_theta2(self) -> tuple[float, float]: ...
    @property
    def theta1(self) -> float: ...
    @property
    def theta2(self) -> float: ...
    @property
    def short_arc(self) -> bool: ...
    @property
    def geometries(self) -> tuple[Point, Point, Point]: ...
    @property
    def angle(self) -> float: ...
    @property
    def length(self) -> float: ...
    def discretize(self, num: int = 2) -> list[Point]: ...
    def revolve(self, *, rotation_angle: float = None, material: Material = None, identifier: str = None, **kwargs: Any) -> ArcRevolve: ...

class ArcRevolve(Revolve):
    def __init__(self, arc: Arc, *args: Any, rotation_angle: float = None, material: Material = None, identifier: str = None, **kwargs: Any) -> None: ...
    @property
    def arc(self) -> Arc: ...
    @property
    def uuid(self) -> str: ...
    @property
    def surface_area(self) -> float: ...
    @property
    def inner_volume(self) -> float: ...
    @property
    def height(self) -> float: ...
    @property
    def geometries(self) -> tuple[Arc, ...]: ...

class Triangle:
    profile: Incomplete
    vertices: Incomplete
    def __init__(self, point1: Point, point2: Point, point3: Point) -> None: ...
    def area(self) -> float: ...
    @property
    def centroid(self) -> tuple[float, float, float]: ...
    @property
    def moment_of_inertia(self) -> tuple[float, float]: ...

class CartesianAxes(Group):
    def __init__(self, origin: Point = ..., axis_length: float = 1, axis_diameter: float = 0.05) -> None: ...

class RDWGSConverter:
    X0: int
    Y0: int
    phi0: float
    lam0: float
    @staticmethod
    def from_rd_to_wgs(coords: tuple[float, float]) -> list[float]: ...
    @staticmethod
    def from_wgs_to_rd(coords: tuple[float, float]) -> list[float]: ...

class Extrusion(Group):
    def __init__(self, profile: list[Point], line: Line, profile_rotation: float = 0, *, material: Material = None, identifier: str = None) -> None: ...
    @property
    def children(self) -> None: ...
    @property
    def profile(self) -> list[Point]: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, material: Material) -> None: ...
    @property
    def line(self) -> Line: ...
    @property
    def length(self) -> float: ...
    @property
    def uuid(self) -> str: ...
    @property
    def geometries(self) -> Line: ...
    @property
    def transformation(self) -> np.ndarray: ...

class ArcExtrusion(Group):
    def __init__(self, profile: list[Point], arc: Arc, profile_rotation: float = 0, n_segments: int = 50, *, material: Material = None, identifier: str = None) -> None: ...
    @property
    def children(self) -> None: ...

class CircularExtrusion(TransformableObject):
    material: Incomplete
    def __init__(self, diameter: float, line: Line, *, shell_thickness: float = None, material: Material = None, identifier: str = None) -> None: ...
    @property
    def line(self) -> Line: ...
    @property
    def length(self) -> float: ...
    @property
    def diameter(self) -> float: ...
    @property
    def radius(self) -> float: ...
    @property
    def shell_thickness(self) -> float | None: ...
    @property
    def cross_sectional_area(self) -> float: ...

class RectangularExtrusion(Extrusion):
    def __init__(self, width: float, height: float, line: Line, profile_rotation: float = 0, *, material: Material = None, identifier: str = None) -> None: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    @property
    def cross_sectional_area(self) -> float: ...
    @property
    def inner_volume(self) -> float: ...

class SquareBeam(RectangularExtrusion):
    def __init__(self, length_x: float, length_y: float, length_z: float, *, material: Material = None, identifier: str = None) -> None: ...

class Pattern(Group):
    base_object: Incomplete
    def __init__(self, base_object: TransformableObject, duplicate_translation_list: list[list[float]], *, identifier: str = None) -> None: ...

class LinearPattern(Pattern):
    def __init__(self, base_object: TransformableObject, direction: list[float], number_of_elements: int, spacing: float, *, identifier: str = None) -> None: ...

class BidirectionalPattern(Pattern):
    def __init__(self, base_object: TransformableObject, direction_1: list[float], direction_2: list[float], number_of_elements_1: int, number_of_elements_2: int, spacing_1: float, spacing_2: float, *, identifier: str = None) -> None: ...

class Polygon(TransformableObject):
    points: Incomplete
    material: Incomplete
    def __init__(self, points: list[Point], *, surface_orientation: bool = False, material: Material = None, skip_duplicate_vertices_check: bool = False, identifier: str = None) -> None: ...
    def has_clockwise_circumference(self) -> bool: ...
    @property
    def cross_sectional_area(self) -> float: ...
    @property
    def centroid(self) -> tuple[float, float]: ...
    @property
    def moment_of_inertia(self) -> tuple[float, float]: ...
    def extrude(self, line: Line, *, profile_rotation: float = 0, material: Material = None, identifier: str = None) -> Extrusion: ...

class Polyline(TransformableObject):
    color: Incomplete
    def __init__(self, points: list[Point], *, color: Color = ..., identifier: str = None) -> None: ...
    @property
    def points(self) -> list[Point]: ...
    @classmethod
    def from_lines(cls, lines: Sequence[Line]) -> Polyline: ...
    def is_equal_to(self, other: Polyline) -> bool: ...
    @property
    def start_point(self) -> Point: ...
    @property
    def end_point(self) -> Point: ...
    @property
    def lines(self) -> list[Line]: ...
    @property
    def x_min(self) -> float | None: ...
    @property
    def x_max(self) -> float | None: ...
    @property
    def y_min(self) -> float | None: ...
    @property
    def y_max(self) -> float | None: ...
    @property
    def z_min(self) -> float | None: ...
    @property
    def z_max(self) -> float | None: ...
    def get_reversed_polyline(self) -> Polyline: ...
    def serialize(self) -> list[dict]: ...
    def filter_duplicate_points(self) -> Polyline: ...
    def is_monotonic_ascending_x(self, strict: bool = True) -> bool: ...
    def is_monotonic_ascending_y(self, strict: bool = True) -> bool: ...
    def intersections_with_polyline(self, other_polyline: Polyline) -> list[Point]: ...
    def intersections_with_x_location(self, x: float) -> list[Point]: ...
    def point_is_on_polyline(self, point: Point) -> bool: ...
    def get_polyline_between(self, start_point: Point, end_point: Point, inclusive: bool = False) -> Polyline: ...
    def find_overlaps(self, other: Polyline) -> list['Polyline']: ...
    def combine_with(self, other: Polyline) -> Polyline: ...
    def split(self, point: Point) -> tuple['Polyline', 'Polyline']: ...
    @classmethod
    def get_lowest_or_highest_profile_x(cls, profile_1: Polyline, profile_2: Polyline, lowest: bool) -> Polyline: ...

class Cone(TransformableObject):
    material: Incomplete
    def __init__(self, diameter: float, height: float, *, origin: Point = None, orientation: Vector = None, material: Material = None, identifier: str = None) -> None: ...
    @classmethod
    def from_line(cls, diameter: float, line: Line, *, material: Material = None, identifier: str = None) -> Cone: ...

class Sphere(TransformableObject):
    centre_point: Incomplete
    radius: Incomplete
    width_segments: Incomplete
    height_segments: Incomplete
    material: Incomplete
    def __init__(self, centre_point: Point, radius: float, width_segments: float = 30, height_segments: float = 30, material: Material = None, *, identifier: str = None) -> None: ...
    def diameter(self) -> float: ...
    def circumference(self) -> float: ...
    def surface_area(self) -> float: ...
    def volume(self) -> float: ...

class Torus(Group):
    def __init__(self, radius_cross_section: float, radius_rotation_axis: float, rotation_angle: float = ..., *, material: Material = None, identifier: str = None) -> None: ...
    @property
    def children(self) -> None: ...
    @property
    def inner_volume(self) -> float: ...
    @property
    def material(self) -> Material: ...
    @material.setter
    def material(self, value: Material) -> None: ...

class TriangleAssembly(TransformableObject):
    material: Incomplete
    def __init__(self, triangles: list[Triangle], *, material: Material = None, skip_duplicate_vertices_check: bool = False, identifier: str = None) -> None: ...

class GeoPoint:
    lat: Incomplete
    lon: Incomplete
    def __init__(self, lat: float, lon: float) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    @classmethod
    def from_rd(cls, coords: tuple[float, float]) -> GeoPoint: ...
    @property
    def rd(self) -> tuple[float, float]: ...

class GeoPolyline:
    def __init__(self, *points: GeoPoint) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    @property
    def points(self) -> list['GeoPoint']: ...

class GeoPolygon:
    def __init__(self, *points: GeoPoint) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    @property
    def points(self) -> list['GeoPoint']: ...

class _Mesh(TransformableObject):
    material: Incomplete
    def __init__(self, vertices: list[list[float]], faces: list[list[int]], material: Material = None, *, identifier: str = None) -> None: ...
    @classmethod
    def from_obj(cls, file: TextIO, material: Material = None, *, identifier: str = None) -> _Mesh: ...

class _MeshAssembly(Group):
    def __init__(self, meshes: list[_Mesh], *, identifier: str = None) -> None: ...
    @classmethod
    def from_obj(cls, file: TextIO, material_library: TextIO = None, default_material: Material = None, *, identifier: str = None) -> _MeshAssembly: ...
