import abc
import os
import requests
import types
from .api_v1 import Entity
from .parametrization import Parametrization
from .views import Summary
from _typeshed import Incomplete
from abc import ABC, ABCMeta, abstractmethod
from collections import OrderedDict
from enum import Enum
from requests.adapters import HTTPAdapter, Retry
from requests_toolbelt import MultipartEncoder
from typing import Any, BinaryIO, Callable, IO, Iterable, NamedTuple, Sequence, TextIO

__all__ = ['Color', 'Controller', 'ViktorController', 'File', 'InitialEntity', 'ParamsFromFile', 'progress_message', 'Storage', 'UserMessage']

class _Result(ABC, metaclass=abc.ABCMeta): ...

class UserMessage:
    class _MessageType(Enum):
        SUCCESS: UserMessage._MessageType
        INFO: UserMessage._MessageType
        WARNING: UserMessage._MessageType
    @classmethod
    def warning(cls, message: str) -> None: ...
    @classmethod
    def info(cls, message: str) -> None: ...
    @classmethod
    def success(cls, message: str) -> None: ...

class _SSLContextAdapter(HTTPAdapter):
    def __init__(self, max_retries: Retry = None) -> None: ...
    def init_poolmanager(self, *args: Any, **kwargs: Any) -> None: ...

class _Session(requests.Session):
    def __init__(self, with_retries: bool) -> None: ...

class _Context:
    job_token: Incomplete
    workspace_id: int
    api_local_cache: OrderedDict
    temp_files: list[str]
    session: requests.Session
    session_with_retries: requests.Session
    @staticmethod
    def clear() -> None: ...

class _OrderedClass(type):
    __fields__: list
    @classmethod
    def __prepare__(mcs, name, bases): ...
    def __new__(cls, name, bases, classdict): ...

class InitialEntity:
    def __init__(self, entity_type_name: str, name: str, *, params: dict | str = None, children: list['InitialEntity'] = None, show_on_dashboard: bool = None) -> None: ...

class ParamsFromFile:
    def __init__(self, *, max_size: int = None, file_types: Sequence[str] = None) -> None: ...
    def __call__(self, process_method: Callable) -> Callable: ...

class Controller(metaclass=_OrderedClass):
    label: str | None
    children: list[str] | None
    show_children_as: str | None
    summary: Summary | None
    parametrization: Parametrization | None
    def __init__(self, **kwargs: Any) -> None: ...
ViktorController = Controller

class _File(ABC, metaclass=abc.ABCMeta):
    def __init__(self, stream: IO) -> None: ...
    def close(self) -> None: ...
    @property
    def closed(self) -> bool: ...
    def fileno(self) -> int: ...
    def flush(self) -> None: ...
    def isatty(self) -> bool: ...
    @property
    def mode(self) -> str: ...
    @property
    def name(self) -> str: ...
    def readable(self) -> bool: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...
    def seekable(self) -> bool: ...
    def tell(self) -> int: ...
    def truncate(self, size: int | None = None) -> int: ...
    def writable(self) -> bool: ...

class _TextFile(_File, TextIO, ABC, metaclass=abc.ABCMeta):
    def read(self, n: int = -1) -> str: ...
    def readline(self, limit: int = -1) -> str: ...
    def readlines(self, hint: int = -1) -> list[str]: ...
    def write(self, s: str) -> int: ...
    def writelines(self, lines: Iterable[str]) -> None: ...
    def __enter__(self) -> TextIO: ...
    def __exit__(self, t: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
    def __iter__(self) -> _TextFile: ...
    def __next__(self) -> str: ...
    @property
    def newlines(self) -> None: ...
    @property
    def buffer(self) -> BinaryIO: ...
    @property
    def encoding(self) -> str: ...
    @property
    def errors(self) -> str | None: ...
    @property
    def line_buffering(self) -> int: ...

class _BinaryFile(_File, BinaryIO, ABC, metaclass=abc.ABCMeta):
    def read(self, n: int = -1) -> bytes: ...
    def readline(self, limit: int = -1) -> bytes: ...
    def readlines(self, hint: int = -1) -> list[bytes]: ...
    def write(self, s: bytes | bytearray) -> int: ...
    def writelines(self, lines: Iterable[bytes]) -> None: ...
    def __enter__(self) -> BinaryIO: ...
    def __exit__(self, t: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
    def __iter__(self) -> _BinaryFile: ...
    def __next__(self) -> bytes: ...

class _TextDataFile(_TextFile):
    def __init__(self, data: str) -> None: ...
    def getvalue(self) -> str: ...

class _BinaryDataFile(_BinaryFile):
    def __init__(self, data: bytes) -> None: ...
    def getvalue(self) -> bytes: ...

class _TextPathFile(_TextFile):
    def __init__(self, path: str | bytes | os.PathLike, encoding: str = None) -> None: ...

class _BinaryPathFile(_BinaryFile):
    def __init__(self, path: str | bytes | os.PathLike) -> None: ...

class _ResponseStream:
    def __init__(self, writable_stream: IO, url: str, headers: dict, binary_mode: bool, encoding: str = None) -> None: ...
    def close(self) -> None: ...
    def __next__(self) -> str | bytes: ...
    def read(self, n: int = -1) -> str | bytes: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...

class _TextURLFile(_TextFile):
    def __init__(self, url: str, headers: dict, encoding: str = None) -> None: ...
    def close(self) -> None: ...
    def read(self, n: int = -1) -> str: ...
    def readline(self, limit: int = -1) -> str: ...
    def readlines(self, hint: int = -1) -> list[str]: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...
    def __next__(self) -> str: ...

class _BinaryURLFile(_BinaryFile):
    def __init__(self, url: str, headers: dict) -> None: ...
    def close(self) -> None: ...
    def read(self, n: int = -1) -> bytes: ...
    def readline(self, limit: int = -1) -> bytes: ...
    def readlines(self, hint: int = -1) -> list[bytes]: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...
    def __next__(self) -> bytes: ...

class _TextWritableFile(_TextFile):
    def __init__(self, path: str | bytes | os.PathLike, encoding: str = None) -> None: ...
    def write(self, s: str) -> int: ...

class _BinaryWritableFile(_BinaryFile):
    def __init__(self, path: str | bytes | os.PathLike) -> None: ...
    def write(self, s: bytes | bytearray) -> int: ...

class _FileManager(ABC, metaclass=abc.ABCMeta):
    @property
    @abstractmethod
    def source(self) -> str | None: ...
    @property
    @abstractmethod
    def writable(self) -> bool: ...
    @abstractmethod
    def create_text_file(self, encoding: str = None) -> TextIO: ...
    @abstractmethod
    def create_binary_file(self) -> BinaryIO: ...

class _DataFileManager(_FileManager):
    source: Incomplete
    writable: bool
    def __init__(self, data: str | bytes) -> None: ...
    def create_text_file(self, encoding: str = None) -> _TextFile: ...
    def create_binary_file(self) -> _BinaryFile: ...

class _PathFileManager(_FileManager):
    writable: bool
    def __init__(self, path: str | bytes | os.PathLike) -> None: ...
    @property
    def source(self) -> str: ...
    def create_text_file(self, encoding: str = None) -> _TextFile: ...
    def create_binary_file(self) -> _BinaryFile: ...

class _URLFileManager(_FileManager):
    writable: bool
    def __init__(self, url: str, headers: dict | None) -> None: ...
    @property
    def source(self) -> str: ...
    def create_text_file(self, encoding: str = None) -> _TextURLFile: ...
    def create_binary_file(self) -> _BinaryURLFile: ...

class _WritableFileManager(_FileManager):
    writable: bool
    def __init__(self) -> None: ...
    @property
    def source(self) -> str: ...
    def create_text_file(self, encoding: str = None) -> _TextWritableFile: ...
    def create_binary_file(self) -> _BinaryWritableFile: ...

class File:
    class SourceType(Enum):
        DATA: File.SourceType
        PATH: File.SourceType
        URL: File.SourceType
        WRITABLE: File.SourceType
    def __init__(self, *, data: str | bytes | None = None, path: str | bytes | os.PathLike | None = None, url: str | None = None, **kwargs: Any) -> None: ...
    @classmethod
    def from_data(cls, data: str | bytes) -> File: ...
    @classmethod
    def from_path(cls, path: str | bytes | os.PathLike) -> File: ...
    @classmethod
    def from_url(cls, url: str, *, headers: dict = None) -> File: ...
    @property
    def source(self) -> str | None: ...
    @property
    def source_type(self) -> SourceType: ...
    @property
    def writable(self) -> bool: ...
    def open(self, encoding: str = None) -> TextIO: ...
    def open_binary(self) -> BinaryIO: ...
    def getvalue(self, encoding: str = None) -> str: ...
    def getvalue_binary(self) -> bytes: ...
    def copy(self, writable: bool = False) -> File: ...

class _MultipartEncoder(MultipartEncoder):
    def __init__(self, data: dict, file: BinaryIO) -> None: ...

class Color(NamedTuple('Color', [('r', int), ('g', int), ('b', int)])):
    def __new__(cls, r: int, g: int, b: int) -> Color: ...
    def __copy__(self) -> Color: ...
    def __deepcopy__(self, memo: dict) -> Color: ...
    def __eq__(self, other: object) -> bool: ...
    @staticmethod
    def black() -> Color: ...
    @staticmethod
    def white() -> Color: ...
    @staticmethod
    def red() -> Color: ...
    @staticmethod
    def lime() -> Color: ...
    @staticmethod
    def green() -> Color: ...
    @staticmethod
    def blue() -> Color: ...
    @staticmethod
    def viktor_black() -> Color: ...
    @staticmethod
    def viktor_blue() -> Color: ...
    @staticmethod
    def viktor_yellow() -> Color: ...
    @classmethod
    def from_hex(cls, hex_value: str) -> Color: ...
    @classmethod
    def from_deltares(cls, value: int) -> Color: ...
    @staticmethod
    def random() -> Color: ...
    @property
    def rgb(self) -> tuple[int, int, int]: ...
    @property
    def hex(self) -> str: ...
    @property
    def deltares(self) -> int: ...
    @staticmethod
    def rgb_to_hex(r: int, g: int, b: int, include_hashtag: bool = True) -> str: ...
    @staticmethod
    def hex_to_rgb(hex_value: str) -> tuple[int, int, int]: ...
    @staticmethod
    def rgb_to_deltares(r: int, g: int, b: int) -> int: ...
    @staticmethod
    def deltares_to_rgb(value: int) -> tuple[int, int, int]: ...

class _SerializableObject(metaclass=ABCMeta): ...

def progress_message(message: str, percentage: float = None) -> None: ...

class Storage:
    def __init__(self) -> None: ...
    def set(self, key: str, data: File, *, scope: str, entity: Entity = None) -> None: ...
    def get(self, key: str, *, scope: str, entity: Entity = None) -> File: ...
    def delete(self, key: str, *, scope: str, entity: Entity = None) -> None: ...
    def list(self, *, prefix: str = None, scope: str, entity: Entity = None) -> dict[str, File]: ...

class _MovedClass:
    new_class: Incomplete
    message: Incomplete
    upgrade_id: Incomplete
    def __init__(self, new_class: type, message: str, upgrade_id: int) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
    def __getattr__(self, attr: Any) -> Any: ...
    def __instancecheck__(self, instance: Any) -> bool: ...
