from ...core import File
from ...geometry import Vector
from ..external_program import ExternalProgram
from .object import ArbitraryProfile, ArbitraryProfileSpan, AveragingStrip, Beam, CircularComposedCrossSection, CircularCrossSection, CircularHollowCrossSection, Concrete, CrossLink, CrossSection, FreeLineLoad, FreePointLoad, FreeSurfaceLoad, GeneralCrossSection, GeneralCrossSectionElement, HingeOnBeam, HingeOnPlane, IntegrationStrip, InternalEdge, Layer, LibraryCrossSection, LineForceSurface, LineLoad, LineMomentOnBeam, LineMomentOnPlane, LineSupportLine, LineSupportSurface, LoadCase, LoadCombination, LoadGroup, Material, MeshSetup, Node, NonLinearFunction, NonLinearLoadCombination, NumericalCrossSection, OpenSlab, Orthotropy, PermanentLoadCase, Plane, PointLoad, PointLoadNode, PointMomentNode, PointSupport, PointSupportLine, ProjectData, RectangularCrossSection, ResultClass, RigidArm, SciaObject, SectionOnBeam, SectionOnPlane, Selection, SolverSetup, Subsoil, SurfaceLoad, SurfaceSupportSurface, ThermalLoad, ThermalSurfaceLoad, VariableLoadCase
from _typeshed import Incomplete
from enum import Enum
from io import BytesIO
from typing import BinaryIO, Sequence

__all__ = ['CalcSetting', 'Model', 'OutputFileParser', 'ResultType', 'SciaAnalysis']

class CalcSetting(Enum):
    NONE: CalcSetting
    NOC: CalcSetting
    LIN: CalcSetting
    NEL: CalcSetting
    EIG: CalcSetting
    STB: CalcSetting
    INF: CalcSetting
    MOB: CalcSetting
    TDA: CalcSetting
    SLN: CalcSetting
    PHA: CalcSetting
    NPH: CalcSetting
    CSS: CalcSetting
    NST: CalcSetting
    TID: CalcSetting

class ResultType(Enum):
    NONE: ResultType
    MODEL: ResultType
    ENGINEERING_REPORT: ResultType

class SciaAnalysis(ExternalProgram):
    input_file: Incomplete
    xml_def_file: Incomplete
    scia_model: Incomplete
    calculation_setting: Incomplete
    xml_doc_name: Incomplete
    def __init__(self, input_file: BytesIO | File, xml_def_file: BytesIO | File, scia_model: BytesIO | File, calculation_setting: CalcSetting = ..., xml_doc_name: str = 'output', *, result_type: ResultType = ..., output_document: str = '') -> None: ...
    @staticmethod
    def get_xml_def_name(input_file: BinaryIO) -> str: ...
    def get_xml_output_file(self, as_file: bool = False) -> BytesIO | File | None: ...
    def get_updated_esa_model(self, as_file: bool = False) -> BytesIO | File | None: ...
    def get_engineering_report(self, as_file: bool = False) -> BytesIO | File | None: ...

class Model:
    def __init__(self, *, mesh_setup: MeshSetup = None, solver_setup: SolverSetup = None, project_data: ProjectData = None) -> None: ...
    @property
    def layers(self) -> tuple[Layer, ...]: ...
    @property
    def concrete_materials(self) -> tuple[Concrete, ...]: ...
    @property
    def nonlinear_functions(self) -> tuple[NonLinearFunction, ...]: ...
    @property
    def subsoils(self) -> tuple[Subsoil, ...]: ...
    @property
    def orthotropy_objects(self) -> tuple[Orthotropy, ...]: ...
    @property
    def selections(self) -> tuple[Selection, ...]: ...
    @property
    def cross_sections(self) -> tuple[CrossSection, ...]: ...
    @property
    def nodes(self) -> tuple[Node, ...]: ...
    @property
    def beams(self) -> tuple[Beam, ...]: ...
    @property
    def cross_links(self) -> tuple[CrossLink, ...]: ...
    @property
    def arbitrary_profiles(self) -> tuple[ArbitraryProfile, ...]: ...
    @property
    def hinges_on_beam(self) -> tuple[HingeOnBeam, ...]: ...
    @property
    def hinges_on_plane(self) -> tuple[HingeOnPlane, ...]: ...
    @property
    def sections_on_beam(self) -> tuple[SectionOnBeam, ...]: ...
    @property
    def sections_on_plane(self) -> tuple[SectionOnPlane, ...]: ...
    @property
    def planes(self) -> tuple[Plane, ...]: ...
    @property
    def open_slabs(self) -> tuple[OpenSlab, ...]: ...
    @property
    def internal_edges(self) -> tuple[InternalEdge, ...]: ...
    @property
    def rigid_arms(self) -> tuple[RigidArm, ...]: ...
    @property
    def point_supports(self) -> tuple[PointSupport, ...]: ...
    @property
    def point_supports_line(self) -> tuple[PointSupportLine, ...]: ...
    @property
    def line_supports_line(self) -> tuple[LineSupportLine, ...]: ...
    @property
    def line_supports_surface(self) -> tuple[LineSupportSurface, ...]: ...
    @property
    def surface_supports(self) -> tuple[SurfaceSupportSurface, ...]: ...
    @property
    def load_cases(self) -> tuple[LoadCase, ...]: ...
    @property
    def load_groups(self) -> tuple[LoadGroup, ...]: ...
    @property
    def load_combinations(self) -> tuple[LoadCombination, ...]: ...
    @property
    def nonlinear_load_combinations(self) -> tuple[NonLinearLoadCombination, ...]: ...
    @property
    def result_classes(self) -> tuple[ResultClass, ...]: ...
    @property
    def point_loads_node(self) -> tuple[PointLoadNode, ...]: ...
    @property
    def point_loads(self) -> tuple[PointLoad, ...]: ...
    @property
    def point_moments_node(self) -> tuple[PointMomentNode, ...]: ...
    @property
    def line_loads(self) -> tuple[LineLoad, ...]: ...
    @property
    def line_moments_on_beam(self) -> tuple[LineMomentOnBeam, ...]: ...
    @property
    def line_moments_on_plane(self) -> tuple[LineMomentOnPlane, ...]: ...
    @property
    def line_force_surface_list(self) -> tuple[LineForceSurface, ...]: ...
    @property
    def surface_loads(self) -> tuple[SurfaceLoad, ...]: ...
    @property
    def thermal_loads(self) -> tuple[ThermalLoad, ...]: ...
    @property
    def thermal_surface_loads(self) -> tuple[ThermalSurfaceLoad, ...]: ...
    @property
    def free_surface_loads(self) -> tuple[FreeSurfaceLoad, ...]: ...
    @property
    def free_line_loads(self) -> tuple[FreeLineLoad, ...]: ...
    @property
    def free_point_loads(self) -> tuple[FreePointLoad, ...]: ...
    @property
    def integration_strips(self) -> tuple[IntegrationStrip, ...]: ...
    @property
    def averaging_strips(self) -> tuple[AveragingStrip, ...]: ...
    @property
    def mesh_setup(self) -> MeshSetup: ...
    @property
    def solver_setup(self) -> SolverSetup: ...
    @property
    def project_data(self) -> ProjectData: ...
    def create_layer(self, name: str = None, *, comment: str = None, structural_model_only: bool = None, current_used_activity: bool = None) -> Layer: ...
    def update_concrete_material(self, object_id: int, name: str, part: Concrete.ECPart, thermal_expansion: float = None, unit_mass: float = None, wet_density: float = None, e_modulus: float = None, poisson: float = None, g_modulus: float = None, log_decrement: float = None, specific_heat: float = None, thermal_conductivity: float = None, *, fck: float = None) -> Concrete: ...
    def create_nonlinear_function(self, name: str, function_type: NonLinearFunction.Type, positive_end: NonLinearFunction.Support, negative_end: NonLinearFunction.Support, impulse: list[tuple[float, float]]) -> NonLinearFunction: ...
    def create_subsoil(self, name: str, *, stiffness: float, c1x: float = None, c1y: float = None, c1z: Subsoil.C1z = None, nonlinear_function: NonLinearFunction = None, c2x: float = None, c2y: float = None, is_drained: bool = None, water_air_in_clay_subgrade: bool = None, specific_weight: float = None, fi: float = None, sigma_oc: float = None, c: float = None, cu: float = None) -> Subsoil: ...
    def create_orthotropy(self, name: str, material: Material, thickness: float, D11: float = None, D22: float = None, D12: float = None, D33: float = None, D44: float = None, D55: float = None, d11: float = None, d22: float = None, d12: float = None, d33: float = None, kxy: float = None, kyx: float = None) -> Orthotropy: ...
    def create_selection(self, name: str, objects: list[SciaObject]) -> Selection: ...
    def create_arbitrary_profile_span(self, length: float, type_of_css: ArbitraryProfileSpan.TypeOfCss, cross_section_start: CrossSection, cross_section_end: CrossSection, alignment: ArbitraryProfileSpan.Alignment) -> ArbitraryProfileSpan: ...
    def create_rectangular_cross_section(self, name: str, material: Material, width: float, height: float) -> RectangularCrossSection: ...
    def create_circular_cross_section(self, name: str, material: Material, diameter: float) -> CircularCrossSection: ...
    def create_circular_hollow_cross_section(self, name: str, material: Material, diameter: float, thickness: float) -> CircularHollowCrossSection: ...
    def create_circular_composed_cross_section(self, name: str, material: Material, material_2: Material, diameter: float, thickness: float) -> CircularComposedCrossSection: ...
    def create_numerical_cross_section(self, name: str, material: Material, *, A: float = None, Ay: float = None, Az: float = None, AL: float = None, AD: float = None, cYUCS: float = None, cZUCS: float = None, alpha: float = None, Iy: float = None, Iz: float = None, Wely: float = None, Welz: float = None, Wply: float = None, Wplz: float = None, Mply_plus: float = None, Mply_min: float = None, Mplz_plus: float = None, Mplz_min: float = None, dy: float = None, dz: float = None, It: float = None, Iw: float = None, beta_y: float = None, beta_z: float = None) -> NumericalCrossSection: ...
    def create_library_cross_section(self, section: LibraryCrossSection.Section, profile: str, material: Material, *, name: str = None) -> LibraryCrossSection: ...
    def create_general_cross_section_element(self, name: str, element_type: GeneralCrossSectionElement.Type, points: Sequence[tuple[float, float]], *, material: Material = None) -> GeneralCrossSectionElement: ...
    def create_general_cross_section(self, elements: Sequence[GeneralCrossSectionElement], *, name: str = None) -> GeneralCrossSection: ...
    def create_node(self, name: str, x: float, y: float, z: float) -> Node: ...
    def create_beam(self, begin_node: Node, end_node: Node, cross_section: CrossSection, *, name: str = None, ez: float = None, lcs_rotation: float = None, layer: Layer = None) -> Beam: ...
    def create_cross_link(self, beam_1: Beam, beam_2: Beam, *, name: str = None) -> CrossLink: ...
    def create_arbitrary_profile(self, name: str, beam: Beam, c_def: ArbitraryProfile.CDef, cross_section: CrossSection, spans: list[ArbitraryProfileSpan]) -> ArbitraryProfile: ...
    def create_hinge_on_beam(self, beam: Beam, position: HingeOnBeam.Position, *, name: str = None, freedom_ux: HingeOnBeam.Freedom = ..., freedom_uy: HingeOnBeam.Freedom = ..., freedom_uz: HingeOnBeam.Freedom = ..., freedom_fix: HingeOnBeam.Freedom = ..., freedom_fiy: HingeOnBeam.Freedom = ..., freedom_fiz: HingeOnBeam.Freedom = ..., stiffness_ux: float = 0, stiffness_uy: float = 0, stiffness_uz: float = 0, stiffness_fix: float = 0, stiffness_fiy: float = 0, stiffness_fiz: float = 0) -> HingeOnBeam: ...
    def create_section_on_beam(self, name: str, beam: Beam, c_def: SectionOnBeam.CDef, position_x: float, origin: SectionOnBeam.Origin, repeat: int, delta_x: float) -> SectionOnBeam: ...
    def create_section_on_plane(self, point_1: tuple[float, float, float], point_2: tuple[float, float, float], *, name: str, draw: SectionOnPlane.Draw = None, direction_of_cut: tuple[float, float, float] = None) -> SectionOnPlane: ...
    def create_rigid_arm(self, name: str, master_node: Node, slave_node: Node, hinge_on_master: bool, hinge_on_slave: bool) -> RigidArm: ...
    def create_plane(self, corner_nodes: list[Node], thickness: float, *, material: Material, name: str = None, plane_type: Plane.Type = None, layer: Layer = None, internal_nodes: list[Node] = None, swap_orientation: bool = None, lcs_rotation: float = None, fem_model: Plane.FEMModel = None, orthotropy: Orthotropy = None) -> Plane: ...
    def create_circular_plane(self, center_node: Node, diameter: float, thickness: float, *, material: Material, axis: Vector | tuple[float, float, float] = None, name: str = None, plane_type: Plane.Type = None, layer: Layer = None, internal_nodes: list[Node] = None, swap_orientation: bool = None, lcs_rotation: float = None, fem_model: Plane.FEMModel = None, orthotropy: Orthotropy = None) -> Plane: ...
    def create_open_slab(self, name: str, plane: Plane, corner_nodes: list[Node]) -> OpenSlab: ...
    def create_internal_edge(self, plane: Plane, node_1: Node, node_2: Node, *, name: str = None) -> InternalEdge: ...
    def create_integration_strip(self, plane: Plane, point_1: tuple[float, float, float], point_2: tuple[float, float, float], width: float) -> IntegrationStrip: ...
    def create_averaging_strip(self, plane: Plane, *, strip_type: AveragingStrip.Type, point_1: tuple[float, float, float], width: float, length: float, angle: float, direction: AveragingStrip.Direction, name: str = None) -> AveragingStrip: ...
    def create_point_support(self, name: str, node: Node, spring_type: PointSupport.Type, freedom: tuple[PointSupport.Freedom, PointSupport.Freedom, PointSupport.Freedom, PointSupport.Freedom, PointSupport.Freedom, PointSupport.Freedom], stiffness: tuple[float, float, float, float, float, float], c_sys: PointSupport.CSys, default_size: float = 0.2, *, angle: tuple[float, float, float] = None) -> PointSupport: ...
    def create_point_support_on_beam(self, beam: Beam, *, name: str = None, x: PointSupportLine.Freedom = None, stiffness_x: float = None, y: PointSupportLine.Freedom = None, stiffness_y: float = None, z: PointSupportLine.Freedom = None, stiffness_z: float = None, rx: PointSupportLine.Freedom = None, stiffness_rx: float = None, ry: PointSupportLine.Freedom = None, stiffness_ry: float = None, rz: PointSupportLine.Freedom = None, stiffness_rz: float = None, default_size: float = None, c_sys: PointSupportLine.CSys = None, c_def: PointSupportLine.CDef = None, position_x: float = None, origin: PointSupportLine.Origin = None, repeat: int = None, delta_x: float = None) -> PointSupportLine: ...
    def create_line_support_on_beam(self, beam: Beam, *, name: str = None, x: LineSupportLine.Freedom = None, stiffness_x: float = None, function_x: NonLinearFunction = None, y: LineSupportLine.Freedom = None, stiffness_y: float = None, function_y: NonLinearFunction = None, z: LineSupportLine.Freedom = None, stiffness_z: float = None, function_z: NonLinearFunction = None, rx: LineSupportLine.Freedom = None, stiffness_rx: float = None, function_rx: NonLinearFunction = None, ry: LineSupportLine.Freedom = None, stiffness_ry: float = None, function_ry: NonLinearFunction = None, rz: LineSupportLine.Freedom = None, stiffness_rz: float = None, function_rz: NonLinearFunction = None, c_sys: LineSupportLine.CSys = None, extent: LineSupportLine.Extent = None, c_def: LineSupportLine.CDef = None, position_x1: float = None, position_x2: float = None, origin: LineSupportLine.Origin = None) -> LineSupportLine: ...
    def create_line_support_on_plane(self, edge: tuple[Plane, int] | InternalEdge, *, name: str = None, x: LineSupportSurface.Freedom = None, stiffness_x: float = None, y: LineSupportSurface.Freedom = None, stiffness_y: float = None, z: LineSupportSurface.Freedom = None, stiffness_z: float = None, rx: LineSupportSurface.Freedom = None, stiffness_rx: float = None, ry: LineSupportSurface.Freedom = None, stiffness_ry: float = None, rz: LineSupportSurface.Freedom = None, stiffness_rz: float = None, c_sys: LineSupportSurface.CSys = None, c_def: LineSupportSurface.CDef = None, position_x1: float = None, position_x2: float = None, origin: LineSupportSurface.Origin = None) -> LineSupportSurface: ...
    def create_surface_support(self, plane: Plane, subsoil: Subsoil, *, name: str = None) -> SurfaceSupportSurface: ...
    def create_hinge_on_plane(self, edge: tuple[Plane, int] | InternalEdge, *, name: str = None, ux: HingeOnPlane.Freedom = None, stiffness_ux: float = None, uy: HingeOnPlane.Freedom = None, stiffness_uy: float = None, uz: HingeOnPlane.Freedom = None, stiffness_uz: float = None, fix: HingeOnPlane.Freedom = None, stiffness_fix: float = None, c_def: HingeOnPlane.CDef = None, position_x1: float = None, position_x2: float = None, origin: HingeOnPlane.Origin = None) -> HingeOnPlane: ...
    def create_load_group(self, name: str, load_option: LoadGroup.LoadOption, relation: LoadGroup.RelationOption = None, load_type: LoadGroup.LoadTypeOption = None) -> LoadGroup: ...
    def create_permanent_load_case(self, name: str, description: str, load_group: LoadGroup, load_type: LoadCase.PermanentLoadType, direction: LoadCase.Direction = None, primary_effect: LoadCase = None) -> PermanentLoadCase: ...
    def create_variable_load_case(self, name: str, description: str, load_group: LoadGroup, load_type: LoadCase.VariableLoadType, specification: LoadCase.Specification = None, duration: LoadCase.Duration = None, primary_effect: LoadCase = None) -> VariableLoadCase: ...
    def create_load_combination(self, name: str, load_type: LoadCombination.Type, load_cases: dict[LoadCase, float], *, description: str = None) -> LoadCombination: ...
    def create_nonlinear_load_combination(self, load_type: NonLinearLoadCombination.Type, load_cases: dict[LoadCase, float], *, name: str = None, description: str = None) -> NonLinearLoadCombination: ...
    def create_result_class(self, name: str, combinations: list[LoadCombination] = None, nonlinear_combinations: list[NonLinearLoadCombination] = None) -> ResultClass: ...
    def create_point_load_node(self, node: Node, load_case: LoadCase, load: float, *, name: str = None, direction: PointLoadNode.Direction = None, c_sys: PointLoadNode.CSys = None, angle: tuple[float, float, float] = None) -> PointLoadNode: ...
    def create_point_load(self, name: str, load_case: LoadCase, beam: Beam, direction: PointLoad.Direction, load_type: PointLoad.Type, load_value: float, c_sys: PointLoad.CSys = None, c_def: PointLoad.CDef = None, position_x: float = None, origin: PointLoad.Origin = None, repeat: int = None, ey: float = None, ez: float = None, *, angle: tuple[float, float, float] = None) -> PointLoad: ...
    def create_point_moment_node(self, node: Node, load_case: LoadCase, load: float, direction: PointMomentNode.Direction, name: str = None, c_sys: PointMomentNode.CSys = ...) -> PointMomentNode: ...
    def create_line_load(self, name: str, load_case: LoadCase, beam: Beam, load_type: LineLoad.Type, distribution: LineLoad.Distribution, load_start: float, load_end: float, direction: LineLoad.Direction, position_start: float, position_end: float, c_def: LineLoad.CDef, c_sys: LineLoad.CSys, origin: LineLoad.Origin, ey: float, ez: float) -> LineLoad: ...
    def create_line_moment_on_beam(self, beam: Beam, load_case: LoadCase, m1: float, m2: float = None, *, name: str = None, direction: LineMomentOnBeam.Direction = None, c_def: LineMomentOnBeam.CDef = None, position_x1: float = None, position_x2: float = None, origin: LineMomentOnBeam.Origin = None) -> LineMomentOnBeam: ...
    def create_line_moment_on_plane(self, edge: tuple[Plane, int] | InternalEdge, m1: float, m2: float = None, *, load_case: LoadCase, name: str = None, direction: LineMomentOnPlane.Direction = None, c_def: LineMomentOnPlane.CDef = None, position_x1: float = None, position_x2: float = None, origin: LineMomentOnPlane.Origin = None) -> LineMomentOnPlane: ...
    def create_line_load_on_plane(self, edge: tuple[Plane, int] | InternalEdge, p1: float, p2: float = None, *, load_case: LoadCase, direction: LineForceSurface.Direction = None, name: str = None, location: LineForceSurface.Location = None, c_sys: LineForceSurface.CSys = None, c_def: LineForceSurface.CDef = None, position_x1: float = None, position_x2: float = None, origin: LineForceSurface.Origin = None) -> LineForceSurface: ...
    def create_surface_load(self, name: str, load_case: LoadCase, plane: Plane, direction: SurfaceLoad.Direction, load_type: SurfaceLoad.Type, load_value: float, c_sys: SurfaceLoad.CSys, location: SurfaceLoad.Location) -> SurfaceLoad: ...
    def create_thermal_load(self, name: str, load_case: LoadCase, beam: Beam, distribution: ThermalLoad.Distribution, delta: float, left_delta: float, right_delta: float, top_delta: float, bottom_delta: float, position_start: float, position_end: float, c_def: ThermalLoad.CDef, origin: ThermalLoad.Origin) -> ThermalLoad: ...
    def create_thermal_surface_load(self, name: str, load_case: LoadCase, plane: Plane, delta: float = None, top_delta: float = None, bottom_delta: float = None) -> ThermalSurfaceLoad: ...
    def create_free_surface_load(self, name: str, load_case: LoadCase, direction: FreeSurfaceLoad.Direction, q1: float, q2: float = None, q3: float = None, points: list[tuple[float, float]] = None, *, distribution: FreeSurfaceLoad.Distribution = None, selection: list[Plane] = None) -> FreeSurfaceLoad: ...
    def create_free_line_load(self, name: str, load_case: LoadCase, point_1: tuple[float, float], point_2: tuple[float, float], direction: FreeLineLoad.Direction, magnitude_1: float, magnitude_2: float) -> FreeLineLoad: ...
    def create_free_point_load(self, name: str, load_case: LoadCase, direction: FreePointLoad.Direction, magnitude: float, position: tuple[float, float]) -> FreePointLoad: ...
    def generate_xml_input(self, as_file: bool = False) -> tuple[BytesIO, BytesIO] | tuple[File, File]: ...

class OutputFileParser:
    @classmethod
    def get_result(cls, file: BinaryIO, table_name: str, *, parent: str = None) -> dict[str, dict]: ...
